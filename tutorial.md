# Tutorial

## Tutorial Objectives

In this tutorial, you will:

- Run the Frank-Wolfe algorithm on a mean field control problem for smart charging.
- Analyze the convergence of the algorithm and identify which parameters slow down or speed up the convergence.
- Evaluate the quality of the mean field approximation based on the number of agents.
- Test the disaggregation on multiple consumption signals to follow. 


## The finite population model

We recall te model.     We consider:
- $N$ EVs
- A state space $S:=\{-1,0,1\}\times\{0,\Delta x,2\Delta x,\ldots,1\}$, where :
    - For any $(m,x)\in S$, $m$ represents the mode of charging ($-1$: discharging, $0$: idle, $1$: charging) and $x$ the State of Charge (SoC).
    - $\Delta x>0$ is a space step used to discretize $[0,1]$.
    - **Example** : if the state of an EV is $({-1},{0.3})$, then the EV is discharging ($m={-1}$) and has a level of battery of ${30\%}$.

- The aggregator controls the <span style="color: red;"> probability </span>  for each EV to swich between the different mode of charging with the control variable ${\color{red}u}$.

- Given the control $u$, for an EV $i$ we have
$$
\mathbb{P}(X^i_{t+1}=(\hat{m},x)\,\vert X^i_{t}=({m},x),u_t) = {\color{red}u_t((\hat{m},x),({m},x))\Delta t}.
$$

More precisely, the quantity ${\color{red}u_t((\hat{m},x),({m},x))\Delta t}$ represents the probability for an EV at time $t$ and with the SOC $x$ to switch from mode $m$ to mode $\hat{m}$.

- The charging rate for an EV at state $(m,x)$ is given by ${b(m,x)}$ and is a data of the problem.

- We assume the interactions between the agents are only through the cost.

- The objective function $J$ is 
    $$
        \displaystyle{   J^N(u,\mu^N):=\frac{1}{N}\sum_{t=1}^{T}\sum_{i=1}^N
    \Big(\mathbb{E}[g_t(X^i_t)]+ \sum_{s\in S}\mathbb{E}[\ell(u_t(s, X^i_t)]\Big)+\sum_{t=1}^{T}\mathbb{E}\big[F_t(r_t,\mu^N_t)\big]}.
    $$
    
    where :
    
    - **Running cost on the state** : $g_t$   
        -  if $t< T$ (electricity cost), then  
                $$
                g_t((m,x))= p_tb(m,x)\Delta t  
                $$
                - if  $t= T$, then 
                $$
                g_t((m,x))= c_1\max(0,(c_2-x))^2 
                $$
                  

        - **Transition cost** : 
        $$\ell(u):= c_3u^2.$$
        - **Coupling cost**: consumption profile tracking
        $$
            F_t(r_t,\mu^N):=c_4\Big(r_t - \Delta t\sum_{(m,x)\in S}\mu_t^N(m,x)b(m,x)\Big)^2,
        $$
         where $r_t$ is a target of energy consumption, $\mu_t^N(m,x)$ the proportion of EVs at state $(m,x)$, and  $b(m,x)$ the power consumption of an EV at state $(m,x)$. The signal $r_t$ is given by the UC problem.

## Mean Field Problem 

- $\rho_t$ is the distribution of the states at time $t$. If $\rho_t(m,x)=0.025$, then at time $t$, a proportion of $2.5\%$ of the mean field fleet is in mode $m$ with a level of battery $x$.

- The control $u$ controls the distribution $\rho$ through the **Kolmogorov equation**
$$
\rho_{t+1}(x)=\sum_{s\in S}\rho_t(s)f(x,s,\rho_t,u_t)
$$

- The mean field cost is :
    $$
          J(u,\rho):= \sum_{t=1}^{T}\sum_{x\in S}  \Big(g_t(x)+ \sum_{s\in S}\ell({u_t(s, x)}\Big)\rho_t(x)+\sum_{t=1}^{T} F_t(r_t,\rho_t)
    $$

- The mean field problem (**MFC**) is :
    $$
    \inf_{u,\rho}\,J(u,\rho), \text{   where  }(u,\rho)\text{ satisfies the Kolmogorov equation }
    $$


**You will find all the parameters of the model in the file** *model.py* 

## The General Frank Wolfe Algorithm

Problem **MFC** is sovlved using the Generalized Frank Wolfe Algorithm  *gfw* defined un gfw.py. The input *nb_max_iter* (int) is the maximum number of iterations.
At each iteration *k*, a couple of variables $(u_k,\rho_k)$ is computed. The sequence of $(u_k,\rho_k)_k$ generated by *gfw()* must converge to the solution of the **MFC Problem**. At each iteration $k$, an upper bound of the optimality gap $\varepsilon_k$ is computed:
$$
  J(u_k,\rho_k)  - \inf_{u,\rho}\,J(u,\rho) \leq  \varepsilon_k.
$$
The sequence $(\varepsilon_k)_k$ generated by the Frank Wolfe algorithm is saved in the list *list_epsilon*.
The function *gfw()* retunes the triplet *(list_epsilon , rho_k , u_k)*

## The file *main.py*

The function *gfw()* is called from the file *main.py* and the output is saved in the triplet *(list_epsilon,rho,u)*. 
The sequence of optimality gap is ploted by the function *plot_primal_gap()* and by the function *plot_log_primal_gap()* in a log-log scale. 
The electric consumption associated with the distribution $\rho$ is computed by the function *build_conso_from_distribution()* and plot by *plot_consumption()*. 

All the output of the algorithm are in the folders output/mfc/figures and output/mfc/data.

## Question 1 

Evaluate the impact of the value of $c_4$ in :
- the consumption signal tracking $r_t$
- in the rate of convergence of the optimality gap of the GFW algorithm to $0$.

 You can modify $c_4$ in the file *model.py*.
```python

#Signal tracking penalization function
c_4 = 5
def phi(r,x):
    return 0.5*c_4*(r - x)**2

```

**Warning** For $c_4$ too large, the numbers of space steps *n_x* and of time steps *n_t* are no more adapted. You can adapt it by taking *n_t* larger in the file *model.py*.

```python
#Choose the number n_x of discrete space steps and 
n_x=10
n_t= T*50    #we advice 50*T


delta_t = T/n_t
delta_x = 1/n_x
ratio=(delta_t)/(delta_x)
print(f'n_t = {n_t}, delta_t = {delta_t}, delta_x = {delta_x}, ratio = { ratio }')
```

## Question 2

The control *u* given by the function *gfw()* is implemented to a finite number of EVs using the function *build_trajectories_markov_chain()*. The associated consumption is compared with the target consumption with the function *plot_consumption()* and with the consumption associated with the mean field distribution with the function *plot_comparison_consumption()*.

Evaluate the quality of the mean field approach with respect to the number of EVs to control.
You can change the number of EVs to control in *main.py* by modifying the variable *n*.
```python
# n is the number of EVs to be controlled
n = number_EV # variable number_EV is defined in model.py. 
```

To avoid running the algorithm each time, set the variable *run_gfw* to *False* at the beginning of *main.py*

## Question 3

The distribution of the SoC of the population of EVs at the beginning and at the end of the period are compared thanks to the function *plot_initial_final_level_soc()*.

Change the initial distribution in *model.py* and observe the impacts on the solutions :

```python

def gen_init_distrib():  
    # Returns the initial distribution

    m_0 = { i :  np.array([0.0 for _ in i_x]) for  i in I }
    
    m_0[0][0] = 1 # all the EV are in mode 0 with 0 SoC at initial time

    return m_0
```

## Question 4

Change the signal to follow (the variable $r_t$) in the file *model.py* by considering another .csv file 

```python
########################## For the mean field model ##########################

signal_data_path =  os.path.join(os.path.dirname(os.path.abspath(__file__)),'..','output','long-term_uc','data','aggreg_ev_france_charging_profiles_2030-1-7.csv')
signal = data_reader.read_signal(v2g = v2g, file_path=signal_data_path) 
```
and correct the date of the beginning of the period correspondingly 

```
#Starting time of the optimization
t_0 = datetime.datetime(year = 2030, month = 1, day = 7, hour = 7, minute = 0)
```
What can you observe ?